%% -*- coding: utf-8 -*-
%%
%% Copyright 2016 Nathan Fiedler. All rights reserved.
%% Use of this source code is governed by a BSD-style
%% license that can be found in the LICENSE file.
%%

-module(inugami).

-export([uuid/6, uuid4/0]).
-export([decode/1, encode/1, urn/1]).
-export([get_version/1, set_version/2]).
-export([get_variant/1, set_variant/1]).
-export([namespace_dns/0, namespace_url/0, namespace_oid/0, namespace_x500/0]).
-export([bitstring_to_bin/1, bin_to_bitstring/1]).

-include("inugami.hrl").

namespace_dns() -> decode(<<"6ba7b810-9dad-11d1-80b4-00c04fd430c8">>).
namespace_url() -> decode(<<"6ba7b811-9dad-11d1-80b4-00c04fd430c8">>).
namespace_oid() -> decode(<<"6ba7b812-9dad-11d1-80b4-00c04fd430c8">>).
namespace_x500() -> decode(<<"6ba7b814-9dad-11d1-80b4-00c04fd430c8">>).

% Construct a UUID from the given bitstring parts.
%
% e.g. inugami:uuid(<<"6ba7b810">>, <<"9dad">>, <<"11d1">>,
%                   <<"80">>, <<"b4">>, <<"00c04fd430c8">>).
uuid(TimeLow, TimeMid, TimeHigh, ClockHigh, ClockLow, Node) ->
    #uuid{
        time_low = inugami:bitstring_to_bin(TimeLow),
        time_mid = inugami:bitstring_to_bin(TimeMid),
        time_high = inugami:bitstring_to_bin(TimeHigh),
        clock_high = inugami:bitstring_to_bin(ClockHigh),
        clock_low = inugami:bitstring_to_bin(ClockLow),
        node = inugami:bitstring_to_bin(Node)
    }.

% Generate a type 4 (random) universally unique identifier.
uuid4() ->
    Rand = crypto:strong_rand_bytes(16),
    <<TimeLow:32, TimeMid:16, TimeHigh:16, ClockHigh:8, ClockLow:8, Node:48>> = Rand,
    Uuid = #uuid{time_low=binary:encode_unsigned(TimeLow),
                 time_mid=binary:encode_unsigned(TimeMid),
                 time_high=binary:encode_unsigned(TimeHigh),
                 clock_high=binary:encode_unsigned(ClockHigh),
                 clock_low=binary:encode_unsigned(ClockLow),
                 node=binary:encode_unsigned(Node)},
    set_variant(set_version(Uuid, 4)).

% Decodes a string or binary representation of a UUID into a #uuid{} record.
decode("urn:uuid:" ++ Input) ->
    decode(Input);
decode(Input) when is_list(Input) ->
    decode(list_to_bitstring(string:to_lower(Input)));
decode(<<"urn:uuid:", Input/bitstring>>) ->
    decode(Input);
decode(<<"{", Input:288/bitstring, "}">>) ->
    decode(Input);
decode(<<TimeLow:64/bitstring,  "-",
         TimeMid:32/bitstring,  "-",
         TimeHigh:32/bitstring, "-",
         ClockHigh:16/bitstring,
         ClockLow:16/bitstring, "-",
         Node:96/bitstring>>) ->
    #uuid{time_low=bitstring_to_bin(TimeLow),
          time_mid=bitstring_to_bin(TimeMid),
          time_high=bitstring_to_bin(TimeHigh),
          clock_high=bitstring_to_bin(ClockHigh),
          clock_low=bitstring_to_bin(ClockLow),
          node=bitstring_to_bin(Node)}.

% Encodes a given #uuid{} record into a binary string.
encode(#uuid{time_low=TimeLow, time_mid=TimeMid, time_high=TimeHigh,
             clock_high=ClockHigh, clock_low=ClockLow, node=Node}) ->
    TL = bin_to_bitstring(TimeLow),
    TM = bin_to_bitstring(TimeMid),
    TH = bin_to_bitstring(TimeHigh),
    CH = bin_to_bitstring(ClockHigh),
    CL = bin_to_bitstring(ClockLow),
    N = bin_to_bitstring(Node),
    <<TL/binary, "-", TM/binary, "-", TH/binary, "-", CH/binary, CL/binary, "-", N/binary>>.

% Encodes a given #uuid{} record into a string, with the URN prefix.
urn(Input) ->
    "urn:uuid:" ++ binary_to_list(encode(Input)).

% Extract the version from the UUID as an 8-bit integer.
get_version(#uuid{time_high=TimeHigh}) ->
    <<V:4/bits, _R/bits>> = TimeHigh,
    <<N:8/integer>> = <<0:4, V/bits>>,
    N.

% Set the version of the given UUID, returning the new record.
set_version(#uuid{time_high=TimeHigh}=Uuid, Version) when is_binary(TimeHigh) ->
    TH = fun (<<_V:4/bits, R/bits>>) ->
        <<Version:4, R/bits>>
    end(TimeHigh),
    Uuid#uuid{time_high=TH}.

% Extract the variant of the given UUID, returning an atom, such as
% variant_rfc4122, which is the default for every UUID generated by this
% module.
get_variant(#uuid{clock_high = <<V:3/bits, _R/bits>>}) when V == <<7:3>> ->
    variant_future;
get_variant(#uuid{clock_high = <<V:3/bits, _R/bits>>}) when V == <<6:3>> ->
    variant_microsoft;
get_variant(#uuid{clock_high = <<V:2/bits, _R/bits>>}) when V == <<2:2>> ->
    variant_rfc4122;
get_variant(#uuid{clock_high = <<V:1/bits, _R/bits>>}) when V == <<0:1>> ->
    variant_ncs;
get_variant(_Uuid) ->
    error(badarg).

% Sets the variant bits as described in RFC 4122.
set_variant(#uuid{clock_high=ClockHigh}=Uuid) when is_binary(ClockHigh) ->
    CH = fun (<<_V:2/bits, R/bits>>) ->
        <<2:2, R/bits>>
    end(ClockHigh),
    Uuid#uuid{clock_high=CH}.

% Convert a bitstring representation of a hexadecimal string (e.g.
% <<"80943206">>) to a proper binary (e.g. <<128,148,50,6>>).
bitstring_to_bin(Bits) ->
    try hexstr_to_bin(bitstring_to_list(Bits)) of
        Result -> Result
    catch
        % translate the error in hexstr_to_bin/2 to what we would expect
        % if we were given some strange input, like "imnothex".
        error:{badmatch, _Reason} -> error(badarg)
    end.

% Convert a binary (e.g. <<128,148,50,6>>) to its hexadecimal string
% representation (e.g. <<"80943206">>).
bin_to_bitstring(Bin) ->
    list_to_bitstring(bin_to_hexstr(Bin)).

%
% The code below comes from Steve Vinoski, via a comment on this blog post:
% http://necrobious.blogspot.com/2008/03/binary-to-hex-string-back-to-binary-in.html
%

% Convert a binary to a hexadecimal string.
bin_to_hexstr(Bin) ->
    lists:flatten([io_lib:format("~2.16.0b", [X]) || X <- binary_to_list(Bin)]).

% Convert a hexadecimal string to a binary.
hexstr_to_bin(S) ->
    hexstr_to_bin(S, []).
hexstr_to_bin([], Acc) ->
    list_to_binary(lists:reverse(Acc));
hexstr_to_bin([X,Y|T], Acc) ->
    {ok, [V], []} = io_lib:fread("~16u", [X,Y]),
    hexstr_to_bin(T, [V | Acc]).
